ğŸ“Œ AtualizaÃ§Ã£o do Controle de Vagas (Evento, Modalidade e Lote)
ğŸ¯ Contexto Geral

O portal de inscriÃ§Ã£o possui eventos com limite de vagas.
Inicialmente, o controle era baseado apenas no limite global do evento, impedindo que mais inscriÃ§Ãµes fossem criadas apÃ³s atingir o limite.

Agora o sistema deve suportar, dentro do mesmo evento,:

Limite global de vagas para o evento

Limite individual por modalidade (opcional)

Limite individual por lote, incluindo:

fechamento automÃ¡tico do lote quando atingir o limite,

ativaÃ§Ã£o automÃ¡tica do prÃ³ximo lote disponÃ­vel.

Tudo preservando atomicidade e alta concorrÃªncia.

ğŸ§  Principais Premissas
1. Evento Ã© o limite principal (hard cap)

Se event.capacity for atingido:

nenhuma inscriÃ§Ã£o adicional Ã© permitida,

independentemente de modalidade ou lote ainda possuÃ­rem vagas.

Regra global: evento lotou â†’ tudo trava

2. Modalidade Ã© um limite local (opcional)

Cada evento pode ter 0 ou mais modalidades.

Exemplos:

Corrida 5K

Corrida 10K

Caminhada

Kids

Podem ter limite individual por modalidade.

Regras:

SituaÃ§Ã£o	Resultado
modalidade possui capacity e atingiu esse valor	trava inscriÃ§Ãµes apenas nessa modalidade
modalidade sem limite definido	depende apenas do evento e do lote
3. Lote controla preÃ§o e vagas dentro da modalidade/evento

Cada modalidade (ou o evento) pode ter 1 ou mais lotes.

Exemplo de lotes:

Nome	Exemplo capacity	Valor
1Âº lote	200 vagas	R$ 100
2Âº lote	300 vagas	R$ 130
3Âº lote	sem limite	R$ 150

Regras:

Somente um lote ativo por modalidade/evento

Quando um lote atingir o limite:

ele Ã© marcado como encerrado

e o prÃ³ximo se torna ativo, se existir

O preÃ§o da inscriÃ§Ã£o Ã© o do lote ativo na hora da confirmaÃ§Ã£o

NÃ£o se deve garantir valor apenas por visualizar na tela.

ğŸ› ï¸ Estrutura de Banco Recomendada
events
id (PK)
name
capacity
vagas_ocupadas
...

event_modalities
id (PK)
event_id (FK)
name
capacity NULLABLE  -- se NULL, sem limite prÃ³prio
vagas_ocupadas INT DEFAULT 0

event_lots
id (PK)
event_id (FK)
modality_id (FK optional)
capacity NULLABLE
vagas_ocupadas INT DEFAULT 0
status ENUM('active', 'closed', 'future')
price_cents INT
order_index INT NOT NULL   -- define a ordem natural dos lotes

registrations
id (PK)
event_id FK
modality_id FK NULLABLE
lot_id FK NULLABLE
athlete_id
status
...


Regra importante:

UNIQUE(event_id, athlete_id)

ğŸ”„ Fluxo AtÃ´mico Atualizado na InscriÃ§Ã£o

Toda inscriÃ§Ã£o segue uma Ãºnica transaÃ§Ã£o contendo 3 travas (quando aplicÃ¡vel):

âœ” Ordem obrigatÃ³ria de locking com SELECT FOR UPDATE

Evento

Modalidade (se houver)

Lote ativo (se houver)

Essa ordem previne deadlocks entre transaÃ§Ãµes concorrentes.

ğŸ” Etapas da transaÃ§Ã£o
BEGIN;

1. Travar evento
SELECT capacity, vagas_ocupadas
FROM events
WHERE id = :event_id
FOR UPDATE;

Se evento lotou:

â†’ rollback
â†’ return: EVENT_FULL

2. Travar modalidade (se enviada)
SELECT capacity, vagas_ocupadas
FROM event_modalities
WHERE id = :modality_id
FOR UPDATE;


Regra:

condiÃ§Ã£o	aÃ§Ã£o
capacity != NULL AND vagas_ocupadas >= capacity	bloquear apenas essa modalidade
modalidade nÃ£o encontrada	erro MODALITY_NOT_FOUND
3. Travar lote ativo
SELECT id, capacity, vagas_ocupadas
FROM event_lots
WHERE event_id = :event_id
  AND (modality_id = :modality_id OR modality_id IS NULL)
  AND status = 'active'
FOR UPDATE;


Regras:

condiÃ§Ã£o	aÃ§Ã£o
lot_capacity atingido	lote vira closed
existe lote future com order_index maior	prÃ³ximo lote vira active
se nÃ£o houver prÃ³ximo lote	esgotado nesta modalidade

ğŸš¨ ImportantÃ­ssimo:

O lote sÃ³ garante o valor no momento do commit da transaÃ§Ã£o.

Isto evita inconsistÃªncia de preÃ§o.

4. Verificar duplicidade

Via UNIQUE constraint:

se violar â†’ erro ALREADY_REGISTERED

5. Criar registro
INSERT INTO registrations (...)
VALUES (...);

6. Atualizar contadores

Cada entidade existente no fluxo incrementa 1:

UPDATE events SET vagas_ocupadas = vagas_ocupadas + 1 WHERE id = :event_id;

UPDATE event_modalities SET vagas_ocupadas = vagas_ocupadas + 1 WHERE id = :modality_id;

UPDATE event_lots SET vagas_ocupadas = vagas_ocupadas + 1 WHERE id = :lot_id;

COMMIT;

âŒ Quando a transaÃ§Ã£o deve falhar
CÃ³digo	Motivo
EVENT_FULL	limite geral atingido
MODALITY_FULL	modalidade atingiu limite
LOT_FULL	lote lotou antes dessa inscriÃ§Ã£o
MODALITY_NOT_FOUND	modalidade invÃ¡lida
LOT_NOT_FOUND	lote invÃ¡lido para modalidade
ALREADY_REGISTERED	mesmo atleta tentando inscriÃ§Ã£o
ğŸ§© EstratÃ©gia para Lote Pago

Como NÃƒO haverÃ¡ reserva prÃ©via, regra a seguir:

Quando o usuÃ¡rio envia o formulÃ¡rio, o backend:

Confirma acesso ao lote ativo via SELECT FOR UPDATE

Garante que ainda hÃ¡ vaga

Gera inscriÃ§Ã£o com lot_id e price_cents daquele lote

Se o lote lotar naquele exato instante:

retorna erro LOT_SOLD_OUT_OR_CHANGED

front deve refazer consulta e exibir novo preÃ§o/lote

Nunca migrar automaticamente o usuÃ¡rio de lote sem consentimento.

ğŸ§ª Testes recomendados
Eventos

âœ” Bloqueia novas inscriÃ§Ãµes quando lotado

Modalidades

âœ” Modalidade lotou, outras continuam abertas
âœ” Modalidade sem limite respeita apenas o evento

Lote

âœ” Lote ativo vira fechado quando lotado
âœ” PrÃ³ximo lote vira ativo
âœ” InscriÃ§Ã£o simultÃ¢nea respeita lote correto

ConcorrÃªncia

âœ” 100 requisiÃ§Ãµes paralelas
â†’ confere que contadores batem
â†’ nenhuma ultrapassa limite

ğŸ’ Resultado Esperado

Com essas implementaÃ§Ãµes:

âœ” Nenhuma condiÃ§Ã£o de corrida gera overbooking
âœ” Sempre confirma a inscriÃ§Ã£o com lote e preÃ§o corretos
âœ” Modalidades podem esgotar individualmente
âœ” Evento pode encerrar todas as inscriÃ§Ãµes
âœ” Com alta concorrÃªncia o sistema se mantÃ©m consistente
âœ” Lote vira de forma segura e previsÃ­vel dentro da transaÃ§Ã£o